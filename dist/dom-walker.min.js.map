{"version":3,"file":"dom-walker.min.js","sources":["../source/default-adapter.js","../source/prefixes.js","../source/augmentations/index.js","../source/utils.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/event.js","../source/augmentations/list.js","../source/augmentations/node.js","../source/htmlro-adapter.js","../source/index.js"],"sourcesContent":["let defaultAdapter = null;\r\n\r\nexport const setDefaultAdapter = (adapter) => {\r\n  defaultAdapter = adapter;\r\n};\r\nexport const getDefaultAdapter = () => defaultAdapter;\r\n","const namePrefixes = {};\r\n\r\nexport const isValidPrefix = (prefix) => (\r\n  typeof prefix === 'string'\r\n  && prefix.length === 1\r\n  && namePrefixes.hasOwnProperty(prefix)\r\n);\r\n\r\nexport const isPrefixedKey = (key) => (\r\n  key\r\n  && typeof(key) === 'string'\r\n  && key.length > 1\r\n  && namePrefixes.hasOwnProperty(key.charAt())\r\n);\r\n\r\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\r\n\r\nexport const setNamePrefix = (prefix, handler) => {\r\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\r\n    throw new Error('Name Prefix must be one character string.');\r\n  }\r\n\r\n  namePrefixes[prefix] = handler;\r\n};\r\n","let augmentations = {};\r\n\r\nexport const resetAugmentations = (augs = {}) => {\r\n  augmentations = augs;\r\n};\r\n\r\nexport const addAugmentations = (augs = {}) => {\r\n  augmentations = {\r\n    ...augmentations,\r\n    ...augs,\r\n  };\r\n};\r\n\r\nexport const hasAugmentation = (key) => (\r\n  key\r\n  && typeof key === 'string'\r\n  && augmentations.hasOwnProperty(key)\r\n);\r\n\r\nexport const getAugmentation = (key) => augmentations[key];\r\n\r\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\r\n","export const isIntKey = (key) => (`${parseInt(key, 10)}` === key);\r\n\r\nexport const getValue = (node, adapter, childName = undefined) => {\r\n  if (childName !== undefined) {\r\n    return adapter.getChildrenByName(node, childName);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nexport const getSingleNode = (node, adapter, childName = undefined) => {\r\n  const value = getValue(node, adapter, childName);\r\n\r\n  if (adapter.isList(value)) {\r\n    return adapter.getNodeAt(node);\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nexport const getNodeList = (node, adapter, childName = undefined) => {\r\n  return adapter.toList(getValue(node, adapter, childName));\r\n};\r\n","import {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n} from './utils';\r\n\r\nimport {\r\n  isPrefixedKey,\r\n  isValidPrefix,\r\n  getPrefixHandler,\r\n} from './prefixes';\r\n\r\nimport {\r\n  hasAugmentation,\r\n  applyAugmentation,\r\n} from './augmentations';\r\n\r\nlet handlers;\r\nlet utils;\r\n\r\nconst createWalkerNode = (node, adapter, childName = undefined) => {\r\n  function TreeWalker() {\r\n    throw new Error('should have been never called');\r\n  }\r\n\r\n  // can be single Node and NodeList with length >= 0\r\n  // should it be always NodeList?\r\n  TreeWalker.node = node;\r\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\r\n  // INFO \"name\" is RO property of Function object\r\n  TreeWalker.childName = childName;\r\n  TreeWalker.adapter = adapter;\r\n  return TreeWalker;\r\n};\r\n\r\nconst wrapWithProxy = (node, adapter, childName = undefined) => {\r\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\r\n};\r\n\r\n// eslint-disable-next-line\r\nutils = {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n  wrapWithProxy,\r\n};\r\n\r\nconst get = ({ node, adapter, childName }, key) => {\r\n  /*\r\n   if string childName used\r\n   if starts with $, return attribute value\r\n   else return wrapper with current single node and property childName\r\n   if numeric index used, use node as parent and childName is undefined\r\n   */\r\n  if (isIntKey(key)) {\r\n    return wrapWithProxy(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    const handler = getPrefixHandler(key);\r\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\r\n  }\r\n\r\n  // return wrap with node and childName\r\n  return wrapWithProxy(getValue(node, adapter, childName), adapter, key);\r\n};\r\n\r\nconst has = ({ node, adapter, childName }, key) => {\r\n  if (isIntKey(key)) {\r\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\r\n    // don't know how to implement this, calling same handler as in GET seems overkill\r\n    return true;\r\n  }\r\n\r\n  return adapter.hasChild(getSingleNode(), key);\r\n};\r\n\r\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\r\n  if (childName === undefined) {\r\n    throw new Error('Cannot call on TreeWalker Node');\r\n  }\r\n\r\n  // this works only of childName === prefix, one char string\r\n  // otherwise it should be passed into arguments\r\n  if (isValidPrefix(childName)) {\r\n    const handler = getPrefixHandler(childName);\r\n    return handler(node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  if (hasAugmentation(childName)) {\r\n    // INFO cannot use target because it contains method's childName, not Node childName\r\n    // call the function with saving context, so other augmentations are accessible via \"this\"\r\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  // FIXME might throw only in dev mode(needs implmentation)\r\n  throw new Error(`\"${childName}\" is not a callable object.`);\r\n};\r\n\r\nhandlers = {\r\n  get,\r\n  has,\r\n  apply,\r\n};\r\n\r\nexport default wrapWithProxy;\r\n\r\n","const toString = (node) => node.toString();\r\nconst valueOf = (node) => node;\r\n\r\nexport default {\r\n  toString,\r\n  valueOf,\r\n  [Symbol.toPrimitive]: (node) => node,\r\n};\r\n","const on = (node, adapter, [ eventType, callback ], utils) => {\r\n  // add even listener\r\n};\r\n\r\nconst off = (node, adapter, [ eventType, callback ], utils) => {\r\n  // remove even listener\r\n};\r\n\r\nconst emmit = (node, adapter, [ event ], utils) => {\r\n  // dispatch event\r\n};\r\n\r\nexport default {\r\n  on,\r\n  off,\r\n  emmit,\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => {\r\n\r\n};\r\n\r\nconst filter = (node, adapter, [ callback ], utils) => {\r\n  // apply filter on element collection\r\n  // allways return wrapped HTMLCollection\r\n};\r\n\r\nconst map = (node, adapter, [ callback, wrapNodes = true ], utils) => {\r\n  // apply map on element collection\r\n  // if wrapNodes in FALSE, will generate normal Array with RAW results in it\r\n  // if wrapNodes in TRUE, will generate wrapped HTMLCollection and put all result into it\r\n};\r\n\r\nconst reduce = (node, adapter, [ callback, head ], utils) => {\r\n  // apply reduce on element collection\r\n};\r\n\r\nexport default {\r\n  length,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce,\r\n};\r\n","const name = (node, adapter, args, utils) =>\r\n  adapter.getName(utils.getSingleNode(node, adapter));\r\n\r\nconst text = (node, adapter) =>\r\n  adapter.getText(node);\r\n\r\nconst children = (node, adapter, [childName], utils) => {\r\n  node = utils.getSingleNode(node, adapter);\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrapWithProxy(list, adapter);\r\n};\r\n\r\n// FIXME move parts to adapter\r\nconst attributes = (node, adapter, args, utils) => {\r\n  const target = utils.getSingleNode(node, adapter);\r\n  if (target.hasAttributes()) {\r\n    return target.attributes;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// FIXME move parts to adapter\r\nconst attribute = (node, adapter, [attrName], utils) => {\r\n  const attrs = attributes(node, adapter, [], utils);\r\n  if (attrs) {\r\n    const attr = attrs.getNamedItem(attrName);\r\n    if (attr) {\r\n      return attr.value;\r\n    }\r\n  }\r\n  return '';\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  adapter.getChildAt(utils.getSingleNode(node, adapter), index);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrapWithProxy(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrapWithProxy(adapter.getNodeParent(node), adapter);\r\n\r\nconst query = (node, adapter, [queryString], utils) => {\r\n\r\n};\r\n\r\nconst queryAll = (node, adapter, [queryString], utils) => {\r\n\r\n};\r\n\r\nexport default {\r\n  name,\r\n  text,\r\n  children,\r\n  attributes,\r\n  attribute,\r\n  childAt,\r\n  root,\r\n  parent,\r\n  query,\r\n  queryAll,\r\n};\r\n","const isList = (node) => node instanceof HTMLCollection || node instanceof Array;\r\n\r\nconst toList = (...args) => {\r\n  const { length } = args;\r\n  const [node] = args;\r\n\r\n  if (length === 1 && isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    const part = args[index];\r\n    if (isList(part)) {\r\n      list.push.call(part);\r\n    } else {\r\n      list.push(part);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst isNode = (node) => node instanceof HTMLElement;\r\n\r\nconst toNode = (node) => {\r\n  // if list we use only first node\r\n  if (isList(node)) {\r\n    return node.length ? node[0] : null;\r\n  }\r\n\r\n  return isNode(node) ? node : null;\r\n};\r\n\r\nconst getNodeAt = (list, index = 0) => {\r\n  if (isList(list)) {\r\n    return list[index];\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst getLength = (list) => list.length;\r\n\r\n// Node\r\nconst getChildren = (node) => {\r\n  node = toNode(node);\r\n\r\n  // if not a node, return empty list\r\n  return isNode(node) ? node.children : toList();\r\n};\r\n\r\nconst getChildrenByName = (node, name) => {\r\n  name = name.toLowerCase();\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  if (!length) {\r\n    return children;\r\n  }\r\n\r\n  const list = [];\r\n\r\n  for (let index = 0; index < children.length; index++) {\r\n    const child = children[index];\r\n    if (child.nodeName.toLowerCase() === name) {\r\n      list.push(child);\r\n    }\r\n  }\r\n\r\n  return list;\r\n};\r\n\r\nconst hasChildren = (node) => !!toNode(node).childElementCount;\r\n\r\nconst hasChild = (node, name) => {\r\n  const children = getChildren(node);\r\n  const { length } = children;\r\n\r\n  for (let index = 0; index < length; index++) {\r\n    if (children[index].nodeName === name) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst getChildAt = (node, index) => getChildren(node)[index];\r\n\r\nconst hasAttribute = (node, name) => toNode(node).hasAttribute(name);\r\n\r\nconst getAttributeValue = (node, name) => toNode(node).getAttribute(name);\r\n\r\nconst getName = (node) => toNode(node).nodeName;\r\n\r\nconst getText = (node) => toNode(node).innerText;\r\n\r\nconst getNodeParent = (node) => toNode(node).parentNode;\r\n\r\nconst getNodeRoot = (node) => toNode(node).getRootNode();\r\n\r\nconst validateRoot = (root) => {\r\n  if (root === undefined || root === document) {\r\n    return document.firstElementChild;\r\n  } else if (typeof root === 'string') {\r\n    return document.querySelector(root);\r\n  }\r\n\r\n  return root;\r\n};\r\n\r\nexport default {\r\n  isList,\r\n  toList,\r\n  isNode,\r\n  getNodeAt,\r\n  getLength,\r\n  getChildren,\r\n  getChildrenByName,\r\n  hasChildren,\r\n  hasChild,\r\n  getChildAt,\r\n  hasAttribute,\r\n  getAttributeValue,\r\n  getName,\r\n  getText,\r\n  getNodeParent,\r\n  getNodeRoot,\r\n  validateRoot,\r\n};\r\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix } from './prefixes';\nimport { addAugmentations, resetAugmentations } from './augmentations';\nimport wrapWithProxy from './wrapper';\n\nimport coreAugmentations from './augmentations/core';\nimport htmlEventAugmentations from './augmentations/event';\nimport htmlListAugmentations from './augmentations/list';\nimport htmlNodeAugmentations from './augmentations/node';\n\nimport HTMLROAdapter from './htmlro-adapter';\n\nconst ATTRIBUTE_KEY = '$';\n\nsetDefaultAdapter(HTMLROAdapter);\n\naddAugmentations(coreAugmentations);\naddAugmentations(htmlNodeAugmentations);\naddAugmentations(htmlListAugmentations);\naddAugmentations(htmlEventAugmentations);\n\nsetNamePrefix(ATTRIBUTE_KEY, (node, adapter, [name]) => adapter.getAttributeValue(node, name));\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrapWithProxy(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n  addAugmentations,\n  resetAugmentations,\n  setNamePrefix,\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","setDefaultAdapter","adapter","getDefaultAdapter","namePrefixes","isPrefixedKey","key","length","hasOwnProperty","charAt","getPrefixHandler","setNamePrefix","prefix","handler","Error","augmentations","addAugmentations","augs","getValue","node","childName","undefined","getChildrenByName","getSingleNode","value","isList","getNodeAt","getNodeList","toList","handlers","utils","wrapWithProxy","isNode","Proxy","TreeWalker","createWalkerNode","isIntKey","substr","hasChild","thisArg","argumentsList","isValidPrefix","hasAugmentation","args","applyAugmentation","toString","Symbol","toPrimitive","eventType","callback","event","getLength","wrapNodes","head","attributes","target","hasAttributes","getName","getText","list","getChildren","attrName","attrs","attr","getNamedItem","index","getChildAt","getNodeRoot","getNodeParent","queryString","HTMLCollection","Array","part","push","call","HTMLElement","toNode","children","name","toLowerCase","child","nodeName","childElementCount","hasAttribute","getAttribute","innerText","parentNode","getRootNode","root","document","firstElementChild","querySelector","coreAugmentations","htmlNodeAugmentations","htmlListAugmentations","htmlEventAugmentations","getAttributeValue","create","validateRoot"],"mappings":"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"}
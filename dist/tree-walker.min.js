!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TreeWalker={})}(this,function(e){"use strict";let t;const r=()=>t;var o,n,a=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r}(o={exports:{}},o.exports),o.exports),s=(n=a)&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n;a.hasOwn;const i={},l=e=>"string"==typeof e&&s(i,e),d=e=>e&&"string"==typeof e&&e.length>1&&s(i,e.charAt()),p=e=>i[e.charAt()],c=e=>"number"==typeof e&&e>>>0===e||`${parseInt(String(e),10)}`===e,u=(e,t,r)=>void 0!==r?t.getChildrenByName(e,r):e,g=(e,t,r)=>t.toNode(u(e,t,r)),f=(e,t,r)=>t.toList(u(e,t,r));let h={};const w=e=>{h=Object.assign({},h,e)},y=e=>e&&"string"==typeof e&&s(h,e);let N,m;const A={constructor:!0,prototype:!0},b=(e,t,r)=>t.isNode(e)||t.isList(e)?new Proxy(((e,t,r)=>{function o(){throw new Error("Should have been never called")}return o.node=e,o.childName=r,o.adapter=t,o})(e,t,r),N):e;m={isIntKey:c,getValue:u,getSingleNode:g,getNodeList:f,wrap:b};N={get:({node:e,adapter:t,childName:r},o)=>{if("symbol"==typeof o||!0===A[o])return e[o];if(c(o))return b(t.getNodeAt(f(e,t,r),o),t);if(d(o))return p(o)(u(e,t,r),t,[o.substr(1)],m);const n=u(e,t,r);return b(n,t,o)},has:({node:e,adapter:t,childName:r},o)=>c(o)?!!t.getNodeAt(f(e,t,r),o):!!d(o)||t.hasChild(g(e,t,r),o),apply:({node:e,adapter:t,childName:r},o,n)=>{if(void 0===r)throw new Error("Cannot call on TreeWalker Node");if(l(r))return p(r)(e,t,[r.substr(1),...n],m);if(y(r))return((e,...t)=>h[e](...t))(r,e,t,n,m);const a=t.toNode(e);if("function"==typeof a[r])return a[r](...n);throw new Error(`"${r}" is not a callable object.`)}};var v={toString:(e,t)=>t.string?t.string(e):e.toString(),valueOf:(e,t)=>t.value?t.value(e):e};const L=(e,t,r,o)=>{const n=[],a=[],s=t.getChildren(e),i=t.getLength(s,t);for(let e=0;e<i;e+=1){const i=s[e];n.push(i),a.push.apply(a,L(i,t,r,o))}return[...n,...a]},x=(e,t,r,o)=>{const[n]=r,a=[],s=[],i=t.getChildren(e),l=t.getLength(i,t);for(let e=0;e<l;e+=1){const l=i[e];t.getName(l)===n&&a.push(l),s.push.apply(s,x(l,t,r,o))}return[...a,...s]};var O={children:(e,t,[r],o)=>{let n;return n=r?t.getChildrenByName(e,r):t.getChildren(e),o.wrap(n,t)},descendants:(e,t,r,o)=>{const[n]=r;return n?o.wrap(x(e,t,r,o),t):o.wrap(L(e,t,r,o),t)},childAt:(e,t,[r=0],o)=>o.wrap(t.getChildAt(e,r),t),root:(e,t,r,o)=>o.wrap(t.getNodeRoot(e),t),parent:(e,t,r,o)=>o.wrap(t.getNodeParent(e),t)};const P=(e,t,r,o)=>{const[n=0]=r;let a;if(t.isList(e)){const r=t.getNodeAt(e,n);r&&(a=r)}else n||(a=e);return o.wrap(a||[],t)};var C={length:(e,t)=>t.isList(e)?t.getLength(e):t.isNode(e)?1:0,at:P,first:(e,t,r,o)=>P(e,t,[0],o),filter:(e,t,[r],o)=>{const n=t.toList(e),a=t.getLength(e),s=[],i=o.wrap(n,t);for(let e=0;e<a;e+=1){const a=t.getNodeAt(n,e);r(o.wrap(a,t),e,i)&&s.push(a)}return o.wrap(s,t)},map:(e,t,[r],o)=>{const n=t.toList(e),a=t.getLength(n),s=[],i=o.wrap(n,t);for(let e=0;e<a;e+=1){const a=t.getNodeAt(n,e),l=r(o.wrap(a,t),e,i);s.push(l)}return s},reduce:(e,t,[r,o],n)=>{const a=t.toList(e),s=t.getLength(e);let i=o;const l=n.wrap(a,t);for(let e=0;e<s;e+=1){const o=t.getNodeAt(a,e);i=r(i,n.wrap(o,t),e,l)}return i}};w(v);const j=(e,t=r())=>b(t.validateRoot(e),t);e.setDefaultAdapter=(e=>{t=e}),e.getDefaultAdapter=r,e.addAugmentations=w,e.hasAugmentation=y,e.resetAugmentations=((e={})=>{h=e}),e.coreAugmentations=v,e.nodeAugmentations=O,e.listAugmentations=C,e.setNamePrefix=((e,t)=>{if("string"!=typeof e||1!==e.length)throw new Error("Name Prefix must be one character string.");i[e]=t}),e.isValidPrefix=l,e.create=j,e.default=j,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=tree-walker.min.js.map

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TreeWalker={})}(this,function(e){"use strict";let t=null;const r=()=>t,n={},o=e=>"string"==typeof e&&1===e.length&&n.hasOwnProperty(e),a=e=>e&&"string"==typeof e&&e.length>1&&n.hasOwnProperty(e.charAt()),i=e=>n[e.charAt()],s=e=>`${parseInt(e,10)}`===e,l=(e,t,r)=>void 0!==r?t.getChildrenByName(e,r):e,d=(e,t,r)=>{const n=l(e,t,r);return t.isList(n)?t.getNodeAt(e):n},p=(e,t,r)=>t.toList(l(e,t,r));let g={};const u=(e={})=>{g=Object.assign({},g,e)},h=e=>e&&"string"==typeof e&&g.hasOwnProperty(e);let c,f;const w=(e,t,r)=>t.isNode(e)||t.isList(e)?new Proxy(((e,t,r)=>{function n(){throw new Error("Should have been never called")}return n.node=e,n.childName=r,n.adapter=t,n})(e,t,r),c):e;f={isIntKey:s,getValue:l,getSingleNode:d,getNodeList:p,wrap:w};c={get:({node:e,adapter:t,childName:r},n)=>{if(s(n))return w(t.getNodeAt(p(e,t,r),n),t);if(a(n))return i(n)(l(e,t,r),t,[n.substr(1)],f);return w(l(e,t,r),t,n)},has:({node:e,adapter:t,childName:r},n)=>s(n)?!!t.getNodeAt(p(e,t,r),n):!!a(n)||t.hasChild(d(),n),apply:({node:e,adapter:t,childName:r},n,a)=>{if(void 0===r)throw new Error("Cannot call on TreeWalker Node");if(o(r))return i(r)(e,t,a,f);if(h(r))return((e,...t)=>g[e](...t))(r,e,t,a,f);throw new Error(`"${r}" is not a callable object.`)}};var m={toString:e=>e.toString(),valueOf:e=>e,[Symbol.toPrimitive]:e=>e};var N={children:(e,t,[r],n)=>{let o;return o=r?t.getChildrenByName(e,r):t.getChildren(e),n.wrap(o,t)},childAt:(e,t,[r=0],n)=>n.wrap(t.getChildAt(e,r),t),root:(e,t,r,n)=>n.wrap(t.getNodeRoot(e),t),parent:(e,t,r,n)=>n.wrap(t.getNodeParent(e),t)};var y={length:(e,t)=>t.isList(e)?t.getLength(e):t.isNode(e)?1:0,first:(e,t,r,n)=>{let o=e;return t.isList(e)&&(e.length?[o]=e:o=[]),n.wrap(o,t)},filter:(e,t,[r],n)=>{e=t.toList(e);const o=[],a=n.wrap(e,t);for(let i=0;i<e.length;i+=1){const s=e[i];r(n.wrap(s,t),i,a)&&o.push(s)}return n.wrap(o,t)},map:(e,t,[r,n=!0],o)=>{e=t.toList(e);const a=[];let i=!0;const s=o.wrap(e,t);for(let n=0;n<e.length;n+=1){const l=e[n],d=r(o.wrap(l,t),n,s);i=i&&t.isNode(d),a.push(d)}return n&&i?o.wrap(a,t):a},reduce:(e,t,[r,n],o)=>{e=t.toList(e);const a=o.wrap(e,t);for(let i=0;i<e.length;i+=1){const s=e[i];n=r(n,o.wrap(s,t),i,a)}return n}};u(m);const A=(e,t=r())=>w(t.validateRoot(e),t);e.setDefaultAdapter=(e=>{t=e}),e.getDefaultAdapter=r,e.addAugmentations=u,e.hasAugmentation=h,e.resetAugmentations=((e={})=>{g=e}),e.coreAugmentations=m,e.nodeAugmentations=N,e.listAugmentations=y,e.setNamePrefix=((e,t)=>{if("string"!=typeof e||1!==e.length)throw new Error("Name Prefix must be one character string.");n[e]=t}),e.isValidPrefix=o,e.create=A,e.default=A,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=tree-walker.min.js.map

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TreeWalker={})}(this,function(e){"use strict";let t=null;const r=()=>t,n={},o=e=>"string"==typeof e&&1===e.length&&n.hasOwnProperty(e),a=e=>e&&"string"==typeof e&&e.length>1&&n.hasOwnProperty(e.charAt()),i=e=>n[e.charAt()],s=e=>`${parseInt(e,10)}`===e,d=(e,t,r)=>void 0!==r?t.getChildrenByName(e,r):e,l=(e,t,r)=>{const n=d(e,t,r);return t.isList(n)?t.getNodeAt(e):n},f=(e,t,r)=>t.toList(d(e,t,r));let u={};const c=(e={})=>{u=Object.assign({},u,e)},h=e=>e&&"string"==typeof e&&u.hasOwnProperty(e);let g,p;const y=(e,t,r)=>t.isNode(e)||t.isList(e)?new Proxy(((e,t,r)=>{function n(){throw new Error("should have been never called")}return n.node=e,n.childName=r,n.adapter=t,n})(e,t,r),g):e;p={isIntKey:s,getValue:d,getSingleNode:l,getNodeList:f,wrapWithProxy:y};g={get:({node:e,adapter:t,childName:r},n)=>{if(s(n))return y(t.getNodeAt(f(e,t,r),n),t);if(a(n))return i(n)(d(e,t,r),t,[n.substr(1)],p);return y(d(e,t,r),t,n)},has:({node:e,adapter:t,childName:r},n)=>s(n)?!!t.getNodeAt(f(e,t,r),n):!!a(n)||t.hasChild(l(),n),apply:({node:e,adapter:t,childName:r},n,a)=>{if(void 0===r)throw new Error("Cannot call on TreeWalker Node");if(o(r))return i(r)(e,t,a,p);if(h(r))return((e,...t)=>u[e](...t))(r,e,t,a,p);throw new Error(`"${r}" is not a callable object.`)}};var m={toString:e=>e.toString(),valueOf:e=>e,[Symbol.toPrimitive]:e=>e};c(m);const N=(e,t=r())=>y(t.validateRoot(e),t);e.setDefaultAdapter=(e=>{t=e}),e.getDefaultAdapter=r,e.addAugmentations=c,e.hasAugmentation=h,e.resetAugmentations=((e={})=>{u=e}),e.coreAugmentations=m,e.setNamePrefix=((e,t)=>{if("string"!=typeof e||1!==e.length)throw new Error("Name Prefix must be one character string.");n[e]=t}),e.isValidPrefix=o,e.create=N,e.default=N,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=tree-walker.min.js.map

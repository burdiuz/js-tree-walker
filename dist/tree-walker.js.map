{"version":3,"file":"tree-walker.js","sources":["../source/default-adapter.js","../node_modules/@actualwave/has-own/has-own.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter;\r\n\r\nexport const setDefaultAdapter = (adapter) => {\r\n  defaultAdapter = adapter;\r\n};\r\nexport const getDefaultAdapter = () => defaultAdapter;\r\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\r\n\r\nconst namePrefixes = {};\r\n\r\nexport const isValidPrefix = (prefix) =>\r\n  typeof prefix === 'string' && hasOwn(namePrefixes, prefix);\r\n\r\nexport const isPrefixedKey = (key) =>\r\n  key &&\r\n  typeof key === 'string' &&\r\n  key.length > 1 &&\r\n  hasOwn(namePrefixes, key.charAt());\r\n\r\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\r\n\r\nexport const setNamePrefix = (prefix, handler) => {\r\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\r\n    throw new Error('Name Prefix must be one character string.');\r\n  }\r\n\r\n  namePrefixes[prefix] = handler;\r\n};\r\n","export const isIntKey = (key) =>\r\n  // it is unsigned int\r\n  (typeof key === 'number' && key >>> 0 === key) ||\r\n  // it is integer number string\r\n  `${parseInt(String(key), 10)}` === key;\r\n\r\nexport const getValue = (node, adapter, childName = undefined) => {\r\n  if (childName !== undefined) {\r\n    return adapter.getChildrenByName(node, childName);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nexport const getSingleNode = (node, adapter, childName = undefined) =>\r\n  adapter.toNode(getValue(node, adapter, childName));\r\n\r\nexport const getNodeList = (node, adapter, childName = undefined) =>\r\n  adapter.toList(getValue(node, adapter, childName));\r\n","import hasOwn from '@actualwave/has-own';\r\n\r\nlet augmentations = {};\r\n\r\nexport const resetAugmentations = (augs = {}) => {\r\n  augmentations = augs;\r\n};\r\n\r\nexport const addAugmentations = (augs) => {\r\n  augmentations = {\r\n    ...augmentations,\r\n    ...augs,\r\n  };\r\n};\r\n\r\nexport const hasAugmentation = (key) =>\r\n  key && typeof key === 'string' && hasOwn(augmentations, key);\r\n\r\nexport const getAugmentation = (key) => augmentations[key];\r\n\r\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\r\n","import { isIntKey, getValue, getSingleNode, getNodeList } from './utils';\r\n\r\nimport { isPrefixedKey, isValidPrefix, getPrefixHandler } from './prefixes';\r\n\r\nimport { hasAugmentation, applyAugmentation } from './augmentations';\r\n\r\nlet handlers;\r\nlet utils;\r\n\r\nconst GET_RESTRICTED_NAMES = {\r\n  constructor: true,\r\n  prototype: true,\r\n  /*\r\n  call: true,\r\n  apply: true,\r\n  */\r\n};\r\n\r\nconst createWalkerNode = (node, adapter, childName = undefined) => {\r\n  function TreeWalker() {\r\n    throw new Error('Should have been never called');\r\n  }\r\n\r\n  // can be single Node and NodeList with length >= 0\r\n  // should it be always NodeList?\r\n  TreeWalker.node = node;\r\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\r\n  // INFO \"name\" is RO property of Function object\r\n  TreeWalker.childName = childName;\r\n  TreeWalker.adapter = adapter;\r\n  return TreeWalker;\r\n};\r\n\r\nconst wrap = (node, adapter, childName = undefined) => {\r\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\r\n};\r\n\r\n// eslint-disable-next-line\r\nutils = {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n  wrap,\r\n};\r\n\r\nconst get = ({ node, adapter, childName }, key) => {\r\n  /*\r\n   if symbol, return node property\r\n   if string childName used\r\n   if starts with $, return attribute value\r\n   else return wrapper with current single node and property childName\r\n   if numeric index used, use node as parent and childName is undefined\r\n   */\r\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\r\n    return node[key];\r\n  }\r\n\r\n  if (isIntKey(key)) {\r\n    return wrap(\r\n      adapter.getNodeAt(getNodeList(node, adapter, childName), key),\r\n      adapter,\r\n    );\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    const handler = getPrefixHandler(key);\r\n    return handler(\r\n      getValue(node, adapter, childName),\r\n      adapter,\r\n      [key.substr(1)],\r\n      utils,\r\n    );\r\n  }\r\n\r\n  const result = getValue(node, adapter, childName);\r\n\r\n  // return wrap with node and childName\r\n  return wrap(result, adapter, key);\r\n};\r\n\r\nconst has = ({ node, adapter, childName }, key) => {\r\n  if (isIntKey(key)) {\r\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\r\n    // don't know how to implement this, calling same handler as in GET seems overkill\r\n    // FIXME let user to register GET and optional SET/HAS handlers\r\n    return true;\r\n  }\r\n\r\n  return adapter.hasChild(getSingleNode(node, adapter, childName), key);\r\n};\r\n\r\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\r\n  if (childName === undefined) {\r\n    throw new Error('Cannot call on TreeWalker Node');\r\n  }\r\n\r\n  // this works only of childName === prefix, one char string\r\n  // otherwise it should be passed into arguments\r\n\r\n  // FIXME if GET always return result of prefixed property, means there are\r\n  // no cases when we get a wrapped node to APPLY trap with prefixed name.\r\n  if (isValidPrefix(childName)) {\r\n    const handler = getPrefixHandler(childName);\r\n    return handler(\r\n      node,\r\n      adapter,\r\n      [childName.substr(1), ...argumentsList],\r\n      utils,\r\n    );\r\n  }\r\n\r\n  if (hasAugmentation(childName)) {\r\n    // INFO cannot use target because it contains method's childName, not Node childName\r\n    // call the function with saving context, so other augmentations are accessible via \"this\"\r\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  // in case of normal function being called out of the tree node\r\n  const targetNode = adapter.toNode(node);\r\n  if (typeof targetNode[childName] === 'function') {\r\n    return targetNode[childName](...argumentsList);\r\n  }\r\n\r\n  // FIXME might throw only in dev mode(needs implementation)\r\n  throw new Error(`\"${childName}\" is not a callable object.`);\r\n};\r\n\r\nhandlers = {\r\n  get,\r\n  has,\r\n  apply,\r\n};\r\n\r\nexport default wrap;\r\n","const toString = (node, adapter) =>\n  adapter.string ? adapter.string(node) : node.toString();\nconst valueOf = (node, adapter) =>\n  adapter.value ? adapter.value(node) : node;\n\nexport default {\n  toString,\n  valueOf,\n};\n","/* eslint-disable prefer-spread */\r\nconst children = (node, adapter, [childName], utils) => {\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrap(list, adapter);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsAll = (node, adapter, args, utils) => {\r\n  const children = []; // eslint-disable-line no-shadow\r\n  const descendants = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    children.push(child);\r\n    descendants.push.apply(\r\n      descendants,\r\n      descendantsAll(child, adapter, args, utils),\r\n    );\r\n  }\r\n\r\n  /* children go first, then other descendants */\r\n  return [...children, ...descendants];\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsByName = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n  const children = []; // eslint-disable-line no-shadow\r\n  const descendants = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    if (adapter.getName(child) === childName) {\r\n      children.push(child);\r\n    }\r\n\r\n    descendants.push.apply(\r\n      descendants,\r\n      descendantsByName(child, adapter, args, utils),\r\n    );\r\n  }\r\n\r\n  /* children go first, then other descendants */\r\n  return [...children, ...descendants];\r\n};\r\n\r\nconst descendants = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n\r\n  if (childName) {\r\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\r\n  }\r\n\r\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  utils.wrap(adapter.getChildAt(node, index), adapter);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeParent(node), adapter);\r\n\r\nexport default {\r\n  children,\r\n  descendants,\r\n  childAt,\r\n  root,\r\n  parent,\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nconst at = (node, adapter, args, utils) => {\r\n  const [index = 0] = args;\r\n  let result;\r\n\r\n  if (adapter.isList(node)) {\r\n    const child = adapter.getNodeAt(node, index);\r\n\r\n    if (child) {\r\n      result = child;\r\n    }\r\n  } else if (!index) {\r\n    result = node;\r\n  }\r\n\r\n  // if nothing found return empty array, which will create empty wrapper for\r\n  // chained calls, this will make next calls errorless.\r\n  return utils.wrap(result || [], adapter);\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\r\n\r\nconst filter = (node, adapter, [callback], utils) => {\r\n  // apply filter on element collection\r\n  // always return wrapped list\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  const result = [];\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\r\n      result.push(child);\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst map = (node, adapter, [callback], utils) => {\r\n  // apply map on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(list);\r\n  const result = [];\r\n\r\n  const wrappedList = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    const childResult = callback(\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedList,\r\n    );\r\n    result.push(childResult);\r\n  }\r\n\r\n  // returns normal array because we don't know if all items in result are nodes\r\n  // and if they are, they will be likely already wrapped\r\n  return result;\r\n};\r\n\r\nconst reduce = (node, adapter, [callback, result], utils) => {\r\n  // apply reduce on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  let lastResult = result;\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    lastResult = callback(\r\n      lastResult,\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedNode,\r\n    );\r\n  }\r\n\r\n  return lastResult;\r\n};\r\n\r\nexport default {\r\n  length,\r\n  at,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce,\r\n};\r\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n\n  setNamePrefix,\n  isValidPrefix,\n\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","setDefaultAdapter","adapter","getDefaultAdapter","namePrefixes","isValidPrefix","prefix","hasOwn","isPrefixedKey","key","length","charAt","getPrefixHandler","setNamePrefix","handler","Error","isIntKey","parseInt","String","getValue","node","childName","undefined","getChildrenByName","getSingleNode","toNode","getNodeList","toList","augmentations","resetAugmentations","augs","addAugmentations","hasAugmentation","applyAugmentation","args","handlers","utils","GET_RESTRICTED_NAMES","createWalkerNode","TreeWalker","wrap","isNode","isList","Proxy","get","getNodeAt","substr","result","has","hasChild","apply","thisArg","argumentsList","targetNode","toString","string","valueOf","value","children","list","getChildren","descendantsAll","descendants","getLength","index","child","push","descendantsByName","getName","childAt","getChildAt","root","getNodeRoot","parent","getNodeParent","at","first","filter","callback","listLength","wrappedNode","map","wrappedList","childResult","reduce","lastResult","coreAugmentations","create","validateRoot"],"mappings":"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"}
{"version":3,"file":"tree-walker.js","sources":["../source/default-adapter.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter = null;\r\n\r\nexport const setDefaultAdapter = (adapter) => {\r\n  defaultAdapter = adapter;\r\n};\r\nexport const getDefaultAdapter = () => defaultAdapter;\r\n","const namePrefixes = {};\r\n\r\nexport const isValidPrefix = (prefix) => (\r\n  typeof prefix === 'string'\r\n  && prefix.length === 1\r\n  && namePrefixes.hasOwnProperty(prefix)\r\n);\r\n\r\nexport const isPrefixedKey = (key) => (\r\n  key\r\n  && typeof key === 'string'\r\n  && key.length > 1\r\n  && namePrefixes.hasOwnProperty(key.charAt())\r\n);\r\n\r\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\r\n\r\nexport const setNamePrefix = (prefix, handler) => {\r\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\r\n    throw new Error('Name Prefix must be one character string.');\r\n  }\r\n\r\n  namePrefixes[prefix] = handler;\r\n};\r\n","export const isIntKey = (key) => (`${parseInt(key, 10)}` === key);\r\n\r\nexport const getValue = (node, adapter, childName = undefined) => {\r\n  if (childName !== undefined) {\r\n    return adapter.getChildrenByName(node, childName);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nexport const getSingleNode = (node, adapter, childName = undefined) => {\r\n  const value = getValue(node, adapter, childName);\r\n\r\n  if (adapter.isList(value)) {\r\n    return adapter.getNodeAt(node);\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nexport const getNodeList = (node, adapter, childName = undefined) => {\r\n  return adapter.toList(getValue(node, adapter, childName));\r\n};\r\n","let augmentations = {};\r\n\r\nexport const resetAugmentations = (augs = {}) => {\r\n  augmentations = augs;\r\n};\r\n\r\nexport const addAugmentations = (augs = {}) => {\r\n  augmentations = {\r\n    ...augmentations,\r\n    ...augs,\r\n  };\r\n};\r\n\r\nexport const hasAugmentation = (key) => (\r\n  key\r\n  && typeof key === 'string'\r\n  && augmentations.hasOwnProperty(key)\r\n);\r\n\r\nexport const getAugmentation = (key) => augmentations[key];\r\n\r\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\r\n","import {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n} from './utils';\r\n\r\nimport {\r\n  isPrefixedKey,\r\n  isValidPrefix,\r\n  getPrefixHandler,\r\n} from './prefixes';\r\n\r\nimport {\r\n  hasAugmentation,\r\n  applyAugmentation,\r\n} from './augmentations';\r\n\r\nlet handlers;\r\nlet utils;\r\n\r\nconst createWalkerNode = (node, adapter, childName = undefined) => {\r\n  function TreeWalker() {\r\n    throw new Error('Should have been never called');\r\n  }\r\n\r\n  // can be single Node and NodeList with length >= 0\r\n  // should it be always NodeList?\r\n  TreeWalker.node = node;\r\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\r\n  // INFO \"name\" is RO property of Function object\r\n  TreeWalker.childName = childName;\r\n  TreeWalker.adapter = adapter;\r\n  return TreeWalker;\r\n};\r\n\r\nconst wrap = (node, adapter, childName = undefined) => {\r\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\r\n};\r\n\r\n// eslint-disable-next-line\r\nutils = {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n  wrap,\r\n};\r\n\r\nconst get = ({ node, adapter, childName }, key) => {\r\n  /*\r\n   if string childName used\r\n   if starts with $, return attribute value\r\n   else return wrapper with current single node and property childName\r\n   if numeric index used, use node as parent and childName is undefined\r\n   */\r\n  if (isIntKey(key)) {\r\n    return wrap(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    const handler = getPrefixHandler(key);\r\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\r\n  }\r\n\r\n  // return wrap with node and childName\r\n  return wrap(getValue(node, adapter, childName), adapter, key);\r\n};\r\n\r\nconst has = ({ node, adapter, childName }, key) => {\r\n  if (isIntKey(key)) {\r\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\r\n    // don't know how to implement this, calling same handler as in GET seems overkill\r\n    return true;\r\n  }\r\n\r\n  return adapter.hasChild(getSingleNode(), key);\r\n};\r\n\r\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\r\n  if (childName === undefined) {\r\n    throw new Error('Cannot call on TreeWalker Node');\r\n  }\r\n\r\n  // this works only of childName === prefix, one char string\r\n  // otherwise it should be passed into arguments\r\n  if (isValidPrefix(childName)) {\r\n    const handler = getPrefixHandler(childName);\r\n    return handler(node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  if (hasAugmentation(childName)) {\r\n    // INFO cannot use target because it contains method's childName, not Node childName\r\n    // call the function with saving context, so other augmentations are accessible via \"this\"\r\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  // FIXME might throw only in dev mode(needs implementation)\r\n  throw new Error(`\"${childName}\" is not a callable object.`);\r\n};\r\n\r\nhandlers = {\r\n  get,\r\n  has,\r\n  apply,\r\n};\r\n\r\nexport default wrap;\r\n\r\n","const toString = (node) => node.toString();\r\nconst valueOf = (node) => node;\r\n\r\nexport default {\r\n  toString,\r\n  valueOf,\r\n  [Symbol.toPrimitive]: (node) => node,\r\n};\r\n","/* eslint-disable prefer-spread */\r\nconst children = (node, adapter, [childName], utils) => {\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrap(list, adapter);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsAll = (node, adapter, args, utils) => {\r\n  const result = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    result.push(child);\r\n    result.push.apply(result, descendantsAll(child, adapter, args, utils));\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsByName = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n  const result = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    if (adapter.getName(child) === childName) {\r\n      result.push(child);\r\n    }\r\n    result.push.apply(result, descendantsByName(child, adapter, args, utils));\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nconst descendants = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n\r\n  if (childName) {\r\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\r\n  }\r\n\r\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  utils.wrap(adapter.getChildAt(node, index), adapter);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeParent(node), adapter);\r\n\r\nexport default {\r\n  children,\r\n  descendants,\r\n  childAt,\r\n  root,\r\n  parent,\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nconst at = (node, adapter, args, utils) => {\r\n  const [index] = args;\r\n  // return empty array, which will create empty wrapper for chained calls,\r\n  // this will make next calls errorless.\r\n  let result = [];\r\n\r\n  if (adapter.isList(node)) {\r\n    const child = adapter.getNodeAt(node, index);\r\n\r\n    if (child) {\r\n      result = child;\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\r\n\r\nconst filter = (node, adapter, [callback], utils) => {\r\n  // apply filter on element collection\r\n  // always return wrapped list\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  const result = [];\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\r\n      result.push(child);\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst map = (node, adapter, [callback, wrapNodes = true], utils) => {\r\n  // apply map on element collection\r\n  // if wrapNodes in FALSE, will generate normal Array with RAW results in it\r\n  // if wrapNodes in TRUE and all elements of resulting list are nodes, will\r\n  //   generate wrapped list and put all result into it\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(list);\r\n  const result = [];\r\n\r\n  let areNodes = true;\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    const childResult = callback(utils.wrap(child, adapter), index, wrappedNode);\r\n    areNodes = areNodes && adapter.isNode(childResult);\r\n    result.push(childResult);\r\n  }\r\n\r\n  return wrapNodes && areNodes ? utils.wrap(result, adapter) : result;\r\n};\r\n\r\nconst reduce = (node, adapter, [callback, result], utils) => {\r\n  // apply reduce on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  let lastResult = result;\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    lastResult = callback(result, utils.wrap(child, adapter), index, wrappedNode);\r\n  }\r\n\r\n  return lastResult;\r\n};\r\n\r\nexport default {\r\n  length,\r\n  at,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce,\r\n};\r\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n\n  setNamePrefix,\n  isValidPrefix,\n\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","setDefaultAdapter","adapter","getDefaultAdapter","namePrefixes","isValidPrefix","prefix","length","hasOwnProperty","isPrefixedKey","key","charAt","getPrefixHandler","setNamePrefix","handler","Error","isIntKey","parseInt","getValue","node","childName","undefined","getChildrenByName","getSingleNode","value","isList","getNodeAt","getNodeList","toList","augmentations","resetAugmentations","augs","addAugmentations","hasAugmentation","applyAugmentation","args","handlers","utils","createWalkerNode","TreeWalker","wrap","isNode","Proxy","get","substr","has","hasChild","apply","thisArg","argumentsList","toString","valueOf","Symbol","toPrimitive","children","list","getChildren","descendantsAll","result","getLength","index","child","push","descendantsByName","getName","descendants","childAt","getChildAt","root","getNodeRoot","parent","getNodeParent","at","first","filter","callback","listLength","wrappedNode","map","wrapNodes","areNodes","childResult","reduce","lastResult","coreAugmentations","create","validateRoot"],"mappings":"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"}
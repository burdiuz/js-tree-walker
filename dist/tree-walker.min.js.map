{"version":3,"file":"tree-walker.min.js","sources":["../source/default-adapter.js","../node_modules/@actualwave/has-own/has-own.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter;\n\nexport const setDefaultAdapter = (adapter) => {\n  defaultAdapter = adapter;\n};\nexport const getDefaultAdapter = () => defaultAdapter;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\n\nexport const GET_KEY = 'get';\nexport const HAS_KEY = 'has';\nexport const SET_KEY = 'set';\nexport const DELETE_KEY = 'deleteProperty';\n\nconst namePrefixes = {};\n\nexport const isValidPrefix = (prefix) => typeof prefix === 'string' && hasOwn(namePrefixes, prefix);\n\nexport const getPrefix = (key) => key.charAt();\n\nexport const isPrefixedKey = (key) => {\n  if (key && typeof key === 'string' && key.length > 1) {\n    return hasOwn(namePrefixes, getPrefix(key));\n  }\n\n  return false;\n};\n\nconst getPrefixHandlers = (key) => namePrefixes[getPrefix(key)];\n\nconst createPrefixHandlerGetter = (type) => (key) => {\n  const handlers = getPrefixHandlers(key);\n\n  return handlers && handlers[type];\n};\n\nexport const getPrefixGetHandler = createPrefixHandlerGetter(GET_KEY);\n\nexport const getPrefixHasHandler = createPrefixHandlerGetter(HAS_KEY);\n\nexport const getPrefixSetHandler = createPrefixHandlerGetter(SET_KEY);\n\nexport const getPrefixDeleteHandler = createPrefixHandlerGetter(DELETE_KEY);\n\nexport const setNamePrefix = (prefix, handler) => {\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\n    throw new Error('Name Prefix must be one character string.');\n  }\n\n  if (typeof handler === 'function') {\n    namePrefixes[prefix] = {\n      get: handler,\n      has: (...args) => handler(...args) !== undefined,\n    };\n  } else {\n    const { get, set, has, deleteProperty } = handler;\n\n    namePrefixes[prefix] = { get, set, has, deleteProperty };\n  }\n};\n","export const isIntKey = (key) => (typeof key === 'number' && key >>> 0 === key)\n  // it is integer number string\n  || `${parseInt(String(key), 10)}` === key;\n\nexport const getValue = (node, adapter, childName = undefined) => {\n  if (childName !== undefined) {\n    return adapter.getChildrenByName(node, childName);\n  }\n\n  return node;\n};\n\nexport const getSingleNode = (node, adapter, childName = undefined) => (\n  adapter.toNode(getValue(node, adapter, childName))\n);\n\nexport const getNodeList = (node, adapter, childName = undefined) => (\n  adapter.toList(getValue(node, adapter, childName))\n);\n","import hasOwn from '@actualwave/has-own';\n\nlet augmentations = {};\n\nexport const resetAugmentations = (augs = {}) => {\n  augmentations = augs;\n};\n\nexport const addAugmentations = (augs) => {\n  augmentations = {\n    ...augmentations,\n    ...augs,\n  };\n};\n\nexport const hasAugmentation = (key) => key && typeof key === 'string' && hasOwn(augmentations, key);\n\nexport const getAugmentation = (key) => augmentations[key];\n\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\n","import { isIntKey, getValue, getSingleNode, getNodeList } from './utils';\n\nimport {\n  GET_KEY,\n  HAS_KEY,\n  SET_KEY,\n  DELETE_KEY,\n  getPrefix,\n  isPrefixedKey,\n  getPrefixGetHandler,\n  getPrefixHasHandler,\n  getPrefixSetHandler,\n  getPrefixDeleteHandler,\n} from './prefixes';\n\nimport { hasAugmentation, applyAugmentation } from './augmentations';\n\nlet handlers;\nlet utils;\n\nconst GET_RESTRICTED_NAMES = {\n  constructor: true,\n  prototype: true,\n  /*\n  call: true,\n  apply: true,\n  */\n};\n\nconst createWalkerNode = (node, adapter, childName = undefined) => {\n  function TreeWalker() {\n    throw new Error('Should have been never called');\n  }\n\n  // can be single Node and NodeList with length >= 0\n  // should it be always NodeList?\n  TreeWalker.node = node;\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\n  // INFO \"name\" is RO property of Function object\n  TreeWalker.childName = childName;\n  TreeWalker.adapter = adapter;\n  return TreeWalker;\n};\n\nconst wrap = (node, adapter, childName = undefined) => {\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\n    return node;\n  }\n\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\n};\n\n// eslint-disable-next-line\nutils = {\n  isIntKey,\n  getValue,\n  getSingleNode,\n  getNodeList,\n  wrap,\n};\n\nconst throwHandlerNotAvailable = (operation, key, handler) => {\n  if (!handler) {\n    throw new Error(`Operation \"${operation}\" is not supported for prefix \"${getPrefix(key)}\".`);\n  }\n};\n\nconst get = ({ node, adapter, childName }, key) => {\n  /*\n   if symbol, return node property\n   if string childName used\n   if starts with prefix, call GET handler\n   else return wrapper with current single node and property childName\n   if numeric index used, use node as parent and childName is undefined\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return getSingleNode(node, adapter, childName)[key];\n  }\n\n  if (isIntKey(key)) {\n    return wrap(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixGetHandler(key);\n\n    throwHandlerNotAvailable(GET_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  const result = getValue(node, adapter, childName);\n\n  // return wrap with node and childName\n  return wrap(result, adapter, key);\n};\n\nconst has = ({ node, adapter, childName }, key) => {\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return key in getSingleNode(node, adapter, childName);\n  }\n\n  if (isIntKey(key)) {\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixHasHandler(key);\n\n    throwHandlerNotAvailable(HAS_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  return adapter.hasChild(getSingleNode(node, adapter, childName), key);\n};\n\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\n  if (childName === undefined) {\n    throw new Error('Cannot call on TreeWalker Node');\n  }\n\n  /* GET always return result of prefixed property, means there are\n     no cases when we get a wrapped node to APPLY trap with prefixed name.\n\n  if (isValidPrefix(childName)) {\n    const handler = getPrefixApplyHandler(childName);\n\n    throwHandlerNotAvailable(APPLY_KEY, childName, handler);\n\n    return handler(\n      node,\n      adapter,\n      [childName.substr(1), ...argumentsList],\n      utils,\n    );\n  }\n  */\n\n  if (hasAugmentation(childName)) {\n    // INFO cannot use target because it contains method's childName, not Node childName\n    // call the function with saving context, so other augmentations are accessible via \"this\"\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\n  }\n\n  // in case of normal function being called out of the tree node\n  const targetNode = adapter.toNode(node);\n  if (typeof targetNode[childName] === 'function') {\n    return targetNode[childName](...argumentsList);\n  }\n\n  // FIXME might throw only in dev mode(needs implementation)\n  throw new Error(`\"${childName}\" is not a callable object.`);\n};\n\nconst set = ({ node, adapter, childName }, key, value) => {\n  /*\n   if symbol, set value directly\n   if starts with prefix, call SET handler\n   else throw an error\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    getSingleNode(node, adapter, childName)[key] = value;\n    return true;\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixSetHandler(key);\n\n    throwHandlerNotAvailable(SET_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1), value], utils);\n  }\n\n  throw new Error(`Operation \"${SET_KEY}\" is not supported for nodes.`);\n};\n\nconst deleteProperty = ({ node, adapter, childName }, key) => {\n  /*\n   if symbol, delete value directly\n   if starts with prefix, call DELETE handler\n   else throw an error\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return delete getSingleNode(node, adapter, childName)[key];\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixDeleteHandler(key);\n\n    throwHandlerNotAvailable(DELETE_KEY, key, handler);\n\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\n  }\n\n  throw new Error(`Operation \"${DELETE_KEY}\" is not supported for nodes.`);\n};\n\nhandlers = {\n  get,\n  has,\n  apply,\n  // only for prefixed keys\n  set,\n  deleteProperty,\n};\n\nexport default wrap;\n","const toString = (node, adapter) => (adapter.string ? adapter.string(node) : node.toString());\nconst valueOf = (node, adapter) => (adapter.value ? adapter.value(node) : node);\n\nexport default {\n  toString,\n  valueOf,\n};\n","/* eslint-disable prefer-spread */\nconst name = (node, adapter) => adapter.getName(node);\n\nconst children = (node, adapter, [childName], utils) => {\n  let list;\n\n  if (childName) {\n    list = adapter.getChildrenByName(node, childName);\n  } else {\n    list = adapter.getChildren(node);\n  }\n\n  return utils.wrap(list, adapter);\n};\n\n/**\n * @internal\n */\nconst descendantsAll = (node, adapter, args, utils) => {\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = list[index];\n    children.push(child);\n    descendants.push.apply(descendants, descendantsAll(child, adapter, args, utils));\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\n/**\n * @internal\n */\nconst descendantsByName = (node, adapter, args, utils) => {\n  const [childName] = args;\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n\n    if (adapter.getName(child) === childName) {\n      children.push(child);\n    }\n\n    descendants.push.apply(descendants, descendantsByName(child, adapter, args, utils));\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\nconst descendants = (node, adapter, args, utils) => {\n  const [childName] = args;\n\n  if (childName) {\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\n  }\n\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\n};\n\nconst childAt = (node, adapter, [index = 0], utils) => utils.wrap(adapter.getChildAt(node, index), adapter);\n\nconst root = (node, adapter, args, utils) => utils.wrap(adapter.getNodeRoot(node), adapter);\n\nconst parent = (node, adapter, args, utils) => utils.wrap(adapter.getNodeParent(node), adapter);\n\nexport default {\n  name,\n  children,\n  descendants,\n  childAt,\n  root,\n  parent,\n};\n","const length = (node, adapter) => {\n  if (adapter.isList(node)) {\n    return adapter.getLength(node);\n  }\n\n  if (adapter.isNode(node)) {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst at = (node, adapter, args, utils) => {\n  const [index = 0] = args;\n  let result;\n\n  if (adapter.isList(node)) {\n    const child = adapter.getNodeAt(node, index);\n\n    if (child) {\n      result = child;\n    }\n  } else if (!index) {\n    result = node;\n  }\n\n  // if nothing found return empty array, which will create empty wrapper for\n  // chained calls, this will make next calls errorless.\n  return utils.wrap(result || [], adapter);\n};\n\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\n\nconst filter = (node, adapter, [callback], utils) => {\n  // apply filter on element collection\n  // always return wrapped list\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  const result = [];\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\n      result.push(child);\n    }\n  }\n\n  return utils.wrap(result, adapter);\n};\n\nconst map = (node, adapter, [callback], utils) => {\n  // apply map on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(list);\n  const result = [];\n\n  const wrappedList = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    const childResult = callback(utils.wrap(child, adapter), index, wrappedList);\n    result.push(childResult);\n  }\n\n  // returns normal array because we don't know if all items in result are nodes\n  // and if they are, they will be likely already wrapped\n  return result;\n};\n\nconst reduce = (node, adapter, [callback, result], utils) => {\n  // apply reduce on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  let lastResult = result;\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    lastResult = callback(lastResult, utils.wrap(child, adapter), index, wrappedNode);\n  }\n\n  return lastResult;\n};\n\nexport default {\n  length,\n  at,\n  first,\n  filter,\n  map,\n  reduce,\n};\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) => wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n  setNamePrefix,\n  isValidPrefix,\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","getDefaultAdapter","Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","namePrefixes","getPrefix","key","charAt","isPrefixedKey","length","createPrefixHandlerGetter","type","handlers","getPrefixHandlers","getPrefixGetHandler","getPrefixHasHandler","getPrefixSetHandler","getPrefixDeleteHandler","isIntKey","parseInt","String","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","toNode","getNodeList","toList","augmentations","addAugmentations","augs","hasAugmentation","utils","GET_RESTRICTED_NAMES","wrap","isNode","isList","Proxy","TreeWalker","Error","createWalkerNode","throwHandlerNotAvailable","operation","handler","getNodeAt","substr","result","hasChild","thisArg","argumentsList","args","applyAugmentation","targetNode","string","toString","descendantsAll","children","descendants","list","getChildren","getLength","index","child","push","apply","descendantsByName","getName","getChildAt","getNodeRoot","getNodeParent","at","callback","listLength","wrappedNode","wrappedList","childResult","lastResult","coreAugmentations","create","root","validateRoot","prefix","get","set","deleteProperty"],"mappings":"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"}
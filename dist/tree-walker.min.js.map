{"version":3,"file":"tree-walker.min.js","sources":["../source/default-adapter.js","../node_modules/@actualwave/has-own/has-own.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter;\r\n\r\nexport const setDefaultAdapter = (adapter) => {\r\n  defaultAdapter = adapter;\r\n};\r\nexport const getDefaultAdapter = () => defaultAdapter;\r\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\r\n\r\nconst namePrefixes = {};\r\n\r\nexport const isValidPrefix = (prefix) =>\r\n  typeof prefix === 'string' && hasOwn(namePrefixes, prefix);\r\n\r\nexport const isPrefixedKey = (key) =>\r\n  key &&\r\n  typeof key === 'string' &&\r\n  key.length > 1 &&\r\n  hasOwn(namePrefixes, key.charAt());\r\n\r\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\r\n\r\nexport const setNamePrefix = (prefix, handler) => {\r\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\r\n    throw new Error('Name Prefix must be one character string.');\r\n  }\r\n\r\n  namePrefixes[prefix] = handler;\r\n};\r\n","export const isIntKey = (key) =>\r\n  // it is unsigned int\r\n  (typeof key === 'number' && key >>> 0 === key) ||\r\n  // it is integer number string\r\n  `${parseInt(String(key), 10)}` === key;\r\n\r\nexport const getValue = (node, adapter, childName = undefined) => {\r\n  if (childName !== undefined) {\r\n    return adapter.getChildrenByName(node, childName);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nexport const getSingleNode = (node, adapter, childName = undefined) =>\r\n  adapter.toNode(getValue(node, adapter, childName));\r\n\r\nexport const getNodeList = (node, adapter, childName = undefined) =>\r\n  adapter.toList(getValue(node, adapter, childName));\r\n","import hasOwn from '@actualwave/has-own';\r\n\r\nlet augmentations = {};\r\n\r\nexport const resetAugmentations = (augs = {}) => {\r\n  augmentations = augs;\r\n};\r\n\r\nexport const addAugmentations = (augs) => {\r\n  augmentations = {\r\n    ...augmentations,\r\n    ...augs,\r\n  };\r\n};\r\n\r\nexport const hasAugmentation = (key) =>\r\n  key && typeof key === 'string' && hasOwn(augmentations, key);\r\n\r\nexport const getAugmentation = (key) => augmentations[key];\r\n\r\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\r\n","import { isIntKey, getValue, getSingleNode, getNodeList } from './utils';\r\n\r\nimport { isPrefixedKey, isValidPrefix, getPrefixHandler } from './prefixes';\r\n\r\nimport { hasAugmentation, applyAugmentation } from './augmentations';\r\n\r\nlet handlers;\r\nlet utils;\r\n\r\nconst GET_RESTRICTED_NAMES = {\r\n  constructor: true,\r\n  prototype: true,\r\n  /*\r\n  call: true,\r\n  apply: true,\r\n  */\r\n};\r\n\r\nconst createWalkerNode = (node, adapter, childName = undefined) => {\r\n  function TreeWalker() {\r\n    throw new Error('Should have been never called');\r\n  }\r\n\r\n  // can be single Node and NodeList with length >= 0\r\n  // should it be always NodeList?\r\n  TreeWalker.node = node;\r\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\r\n  // INFO \"name\" is RO property of Function object\r\n  TreeWalker.childName = childName;\r\n  TreeWalker.adapter = adapter;\r\n  return TreeWalker;\r\n};\r\n\r\nconst wrap = (node, adapter, childName = undefined) => {\r\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\r\n};\r\n\r\n// eslint-disable-next-line\r\nutils = {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n  wrap,\r\n};\r\n\r\nconst get = ({ node, adapter, childName }, key) => {\r\n  /*\r\n   if symbol, return node property\r\n   if string childName used\r\n   if starts with $, return attribute value\r\n   else return wrapper with current single node and property childName\r\n   if numeric index used, use node as parent and childName is undefined\r\n   */\r\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\r\n    return node[key];\r\n  }\r\n\r\n  if (isIntKey(key)) {\r\n    return wrap(\r\n      adapter.getNodeAt(getNodeList(node, adapter, childName), key),\r\n      adapter,\r\n    );\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    const handler = getPrefixHandler(key);\r\n    return handler(\r\n      getValue(node, adapter, childName),\r\n      adapter,\r\n      [key.substr(1)],\r\n      utils,\r\n    );\r\n  }\r\n\r\n  const result = getValue(node, adapter, childName);\r\n\r\n  // return wrap with node and childName\r\n  return wrap(result, adapter, key);\r\n};\r\n\r\nconst has = ({ node, adapter, childName }, key) => {\r\n  if (isIntKey(key)) {\r\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\r\n    // don't know how to implement this, calling same handler as in GET seems overkill\r\n    // FIXME let user to register GET and optional SET/HAS handlers\r\n    return true;\r\n  }\r\n\r\n  return adapter.hasChild(getSingleNode(node, adapter, childName), key);\r\n};\r\n\r\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\r\n  if (childName === undefined) {\r\n    throw new Error('Cannot call on TreeWalker Node');\r\n  }\r\n\r\n  // this works only of childName === prefix, one char string\r\n  // otherwise it should be passed into arguments\r\n\r\n  // FIXME if GET always return result of prefixed property, means there are\r\n  // no cases when we get a wrapped node to APPLY trap with prefixed name.\r\n  if (isValidPrefix(childName)) {\r\n    const handler = getPrefixHandler(childName);\r\n    return handler(\r\n      node,\r\n      adapter,\r\n      [childName.substr(1), ...argumentsList],\r\n      utils,\r\n    );\r\n  }\r\n\r\n  if (hasAugmentation(childName)) {\r\n    // INFO cannot use target because it contains method's childName, not Node childName\r\n    // call the function with saving context, so other augmentations are accessible via \"this\"\r\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  // in case of normal function being called out of the tree node\r\n  const targetNode = adapter.toNode(node);\r\n  if (typeof targetNode[childName] === 'function') {\r\n    return targetNode[childName](...argumentsList);\r\n  }\r\n\r\n  // FIXME might throw only in dev mode(needs implementation)\r\n  throw new Error(`\"${childName}\" is not a callable object.`);\r\n};\r\n\r\nhandlers = {\r\n  get,\r\n  has,\r\n  apply,\r\n};\r\n\r\nexport default wrap;\r\n","const toString = (node, adapter) =>\n  adapter.string ? adapter.string(node) : node.toString();\nconst valueOf = (node, adapter) =>\n  adapter.value ? adapter.value(node) : node;\n\nexport default {\n  toString,\n  valueOf,\n};\n","/* eslint-disable prefer-spread */\r\nconst children = (node, adapter, [childName], utils) => {\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrap(list, adapter);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsAll = (node, adapter, args, utils) => {\r\n  const children = []; // eslint-disable-line no-shadow\r\n  const descendants = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    children.push(child);\r\n    descendants.push.apply(\r\n      descendants,\r\n      descendantsAll(child, adapter, args, utils),\r\n    );\r\n  }\r\n\r\n  /* children go first, then other descendants */\r\n  return [...children, ...descendants];\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsByName = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n  const children = []; // eslint-disable-line no-shadow\r\n  const descendants = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    if (adapter.getName(child) === childName) {\r\n      children.push(child);\r\n    }\r\n\r\n    descendants.push.apply(\r\n      descendants,\r\n      descendantsByName(child, adapter, args, utils),\r\n    );\r\n  }\r\n\r\n  /* children go first, then other descendants */\r\n  return [...children, ...descendants];\r\n};\r\n\r\nconst descendants = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n\r\n  if (childName) {\r\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\r\n  }\r\n\r\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  utils.wrap(adapter.getChildAt(node, index), adapter);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeParent(node), adapter);\r\n\r\nexport default {\r\n  children,\r\n  descendants,\r\n  childAt,\r\n  root,\r\n  parent,\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nconst at = (node, adapter, args, utils) => {\r\n  const [index = 0] = args;\r\n  let result;\r\n\r\n  if (adapter.isList(node)) {\r\n    const child = adapter.getNodeAt(node, index);\r\n\r\n    if (child) {\r\n      result = child;\r\n    }\r\n  } else if (!index) {\r\n    result = node;\r\n  }\r\n\r\n  // if nothing found return empty array, which will create empty wrapper for\r\n  // chained calls, this will make next calls errorless.\r\n  return utils.wrap(result || [], adapter);\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\r\n\r\nconst filter = (node, adapter, [callback], utils) => {\r\n  // apply filter on element collection\r\n  // always return wrapped list\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  const result = [];\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\r\n      result.push(child);\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst map = (node, adapter, [callback], utils) => {\r\n  // apply map on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(list);\r\n  const result = [];\r\n\r\n  const wrappedList = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    const childResult = callback(\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedList,\r\n    );\r\n    result.push(childResult);\r\n  }\r\n\r\n  // returns normal array because we don't know if all items in result are nodes\r\n  // and if they are, they will be likely already wrapped\r\n  return result;\r\n};\r\n\r\nconst reduce = (node, adapter, [callback, result], utils) => {\r\n  // apply reduce on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  let lastResult = result;\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    lastResult = callback(\r\n      lastResult,\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedNode,\r\n    );\r\n  }\r\n\r\n  return lastResult;\r\n};\r\n\r\nexport default {\r\n  length,\r\n  at,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce,\r\n};\r\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n\n  setNamePrefix,\n  isValidPrefix,\n\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","getDefaultAdapter","Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","namePrefixes","isValidPrefix","prefix","isPrefixedKey","key","length","charAt","getPrefixHandler","isIntKey","parseInt","String","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","toNode","getNodeList","toList","augmentations","addAugmentations","augs","hasAugmentation","handlers","utils","GET_RESTRICTED_NAMES","wrap","isNode","isList","Proxy","TreeWalker","Error","createWalkerNode","getNodeAt","handler","substr","result","hasChild","thisArg","argumentsList","args","applyAugmentation","targetNode","string","toString","descendantsAll","children","descendants","list","getChildren","getLength","index","child","push","apply","descendantsByName","getName","getChildAt","getNodeRoot","getNodeParent","at","callback","listLength","wrappedNode","wrappedList","childResult","lastResult","coreAugmentations","create","root","validateRoot"],"mappings":"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"}
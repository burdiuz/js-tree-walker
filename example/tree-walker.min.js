!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.TreeWalker={})}(this,function(t){"use strict";let e=null;const r=()=>e,n={},o=t=>"string"==typeof t&&1===t.length&&n.hasOwnProperty(t),a=t=>t&&"string"==typeof t&&t.length>1&&n.hasOwnProperty(t.charAt()),s=t=>n[t.charAt()],i=t=>`${parseInt(t,10)}`===t,d=(t,e,r)=>void 0!==r?e.getChildrenByName(t,r):t,l=(t,e,r)=>{const n=d(t,e,r);return e.isList(n)?e.getNodeAt(t):n},g=(t,e,r)=>e.toList(d(t,e,r));let p={};const c=(t={})=>{p=Object.assign({},p,t)},u=t=>t&&"string"==typeof t&&p.hasOwnProperty(t);let h,f;const w=(t,e,r)=>e.isNode(t)||e.isList(t)?new Proxy(((t,e,r)=>{function n(){throw new Error("Should have been never called")}return n.node=t,n.childName=r,n.adapter=e,n})(t,e,r),h):t;f={isIntKey:i,getValue:d,getSingleNode:l,getNodeList:g,wrap:w};h={get:({node:t,adapter:e,childName:r},n)=>{if(i(n))return w(e.getNodeAt(g(t,e,r),n),e);if(a(n))return s(n)(d(t,e,r),e,[n.substr(1)],f);return w(d(t,e,r),e,n)},has:({node:t,adapter:e,childName:r},n)=>i(n)?!!e.getNodeAt(g(t,e,r),n):!!a(n)||e.hasChild(l(),n),apply:({node:t,adapter:e,childName:r},n,a)=>{if(void 0===r)throw new Error("Cannot call on TreeWalker Node");if(o(r))return s(r)(t,e,a,f);if(u(r))return((t,...e)=>p[t](...e))(r,t,e,a,f);throw new Error(`"${r}" is not a callable object.`)}};var N={toString:t=>t.toString(),valueOf:t=>t,[Symbol.toPrimitive]:t=>t};const m=(t,e,r,n)=>{const o=[],a=e.getChildren(t),s=e.getLength(a,e);for(let t=0;t<s;t+=1){const s=a[t];o.push(s),o.push.apply(o,m(s,e,r,n))}return o},y=(t,e,r,n)=>{const[o]=r,a=[],s=e.getChildren(t),i=e.getLength(s,e);for(let t=0;t<i;t+=1){const i=s[t];e.getName(i)===o&&a.push(i),a.push.apply(a,y(i,e,r,n))}return a};var A={children:(t,e,[r],n)=>{let o;return o=r?e.getChildrenByName(t,r):e.getChildren(t),n.wrap(o,e)},descendants:(t,e,r,n)=>{const[o]=r;return o?n.wrap(y(t,e,r,n),e):n.wrap(m(t,e,r,n),e)},childAt:(t,e,[r=0],n)=>n.wrap(e.getChildAt(t,r),e),root:(t,e,r,n)=>n.wrap(e.getNodeRoot(t),e),parent:(t,e,r,n)=>n.wrap(e.getNodeParent(t),e)};const L=(t,e,r,n)=>{const[o]=r;let a=[];if(e.isList(t)){const r=e.getNodeAt(t,o);r&&(a=r)}return n.wrap(a,e)};var v={length:(t,e)=>e.isList(t)?e.getLength(t):e.isNode(t)?1:0,at:L,first:(t,e,r,n)=>L(t,e,[0],n),filter:(t,e,[r],n)=>{const o=e.toList(t),a=e.getLength(t),s=[],i=n.wrap(o,e);for(let t=0;t<a;t+=1){const a=e.getNodeAt(o,t);r(n.wrap(a,e),t,i)&&s.push(a)}return n.wrap(s,e)},map:(t,e,[r,n=!0],o)=>{const a=e.toList(t),s=e.getLength(a),i=[];let d=!0;const l=o.wrap(a,e);for(let t=0;t<s;t+=1){const n=e.getNodeAt(a,t),s=r(o.wrap(n,e),t,l);d=d&&e.isNode(s),i.push(s)}return n&&d?o.wrap(i,e):i},reduce:(t,e,[r,n],o)=>{const a=e.toList(t),s=e.getLength(t);let i=n;const d=o.wrap(a,e);for(let t=0;t<s;t+=1){const s=e.getNodeAt(a,t);i=r(n,o.wrap(s,e),t,d)}return i}};c(N);const P=(t,e=r())=>w(e.validateRoot(t),e);t.setDefaultAdapter=(t=>{e=t}),t.getDefaultAdapter=r,t.addAugmentations=c,t.hasAugmentation=u,t.resetAugmentations=((t={})=>{p=t}),t.coreAugmentations=N,t.nodeAugmentations=A,t.listAugmentations=v,t.setNamePrefix=((t,e)=>{if("string"!=typeof t||1!==t.length)throw new Error("Name Prefix must be one character string.");n[t]=e}),t.isValidPrefix=o,t.create=P,t.default=P,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=tree-walker.min.js.map

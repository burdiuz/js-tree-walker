{"version":3,"file":"tree-walker.min.js","sources":["../source/default-adapter.js","../node_modules/@actualwave/has-own/has-own.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter;\n\nexport const setDefaultAdapter = (adapter) => {\n  defaultAdapter = adapter;\n};\nexport const getDefaultAdapter = () => defaultAdapter;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\n\nconst namePrefixes = {};\n\nexport const isValidPrefix = (prefix) =>\n  typeof prefix === 'string' && hasOwn(namePrefixes, prefix);\n\nexport const isPrefixedKey = (key) =>\n  key &&\n  typeof key === 'string' &&\n  key.length > 1 &&\n  hasOwn(namePrefixes, key.charAt());\n\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\n\nexport const setNamePrefix = (prefix, handler) => {\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\n    throw new Error('Name Prefix must be one character string.');\n  }\n\n  namePrefixes[prefix] = handler;\n};\n","export const isIntKey = (key) =>\n  // it is unsigned int\n  (typeof key === 'number' && key >>> 0 === key) ||\n  // it is integer number string\n  `${parseInt(String(key), 10)}` === key;\n\nexport const getValue = (node, adapter, childName = undefined) => {\n  if (childName !== undefined) {\n    return adapter.getChildrenByName(node, childName);\n  }\n\n  return node;\n};\n\nexport const getSingleNode = (node, adapter, childName = undefined) =>\n  adapter.toNode(getValue(node, adapter, childName));\n\nexport const getNodeList = (node, adapter, childName = undefined) =>\n  adapter.toList(getValue(node, adapter, childName));\n","import hasOwn from '@actualwave/has-own';\n\nlet augmentations = {};\n\nexport const resetAugmentations = (augs = {}) => {\n  augmentations = augs;\n};\n\nexport const addAugmentations = (augs) => {\n  augmentations = {\n    ...augmentations,\n    ...augs,\n  };\n};\n\nexport const hasAugmentation = (key) =>\n  key && typeof key === 'string' && hasOwn(augmentations, key);\n\nexport const getAugmentation = (key) => augmentations[key];\n\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\n","import { isIntKey, getValue, getSingleNode, getNodeList } from './utils';\n\nimport { isPrefixedKey, isValidPrefix, getPrefixHandler } from './prefixes';\n\nimport { hasAugmentation, applyAugmentation } from './augmentations';\n\nlet handlers;\nlet utils;\n\nconst GET_RESTRICTED_NAMES = {\n  constructor: true,\n  prototype: true,\n  /*\n  call: true,\n  apply: true,\n  */\n};\n\nconst createWalkerNode = (node, adapter, childName = undefined) => {\n  function TreeWalker() {\n    throw new Error('Should have been never called');\n  }\n\n  // can be single Node and NodeList with length >= 0\n  // should it be always NodeList?\n  TreeWalker.node = node;\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\n  // INFO \"name\" is RO property of Function object\n  TreeWalker.childName = childName;\n  TreeWalker.adapter = adapter;\n  return TreeWalker;\n};\n\nconst wrap = (node, adapter, childName = undefined) => {\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\n    return node;\n  }\n\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\n};\n\n// eslint-disable-next-line\nutils = {\n  isIntKey,\n  getValue,\n  getSingleNode,\n  getNodeList,\n  wrap,\n};\n\nconst get = ({ node, adapter, childName }, key) => {\n  /*\n   if symbol, return node property\n   if string childName used\n   if starts with $, return attribute value\n   else return wrapper with current single node and property childName\n   if numeric index used, use node as parent and childName is undefined\n   */\n  if (typeof key === 'symbol' || GET_RESTRICTED_NAMES[key] === true) {\n    return node[key];\n  }\n\n  if (isIntKey(key)) {\n    return wrap(\n      adapter.getNodeAt(getNodeList(node, adapter, childName), key),\n      adapter,\n    );\n  }\n\n  if (isPrefixedKey(key)) {\n    const handler = getPrefixHandler(key);\n    return handler(\n      getValue(node, adapter, childName),\n      adapter,\n      [key.substr(1)],\n      utils,\n    );\n  }\n\n  const result = getValue(node, adapter, childName);\n\n  // return wrap with node and childName\n  return wrap(result, adapter, key);\n};\n\nconst has = ({ node, adapter, childName }, key) => {\n  if (isIntKey(key)) {\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\n  }\n\n  if (isPrefixedKey(key)) {\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\n    // don't know how to implement this, calling same handler as in GET seems overkill\n    // FIXME let user to register GET and optional SET/HAS handlers\n    return true;\n  }\n\n  return adapter.hasChild(getSingleNode(node, adapter, childName), key);\n};\n\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\n  if (childName === undefined) {\n    throw new Error('Cannot call on TreeWalker Node');\n  }\n\n  // this works only of childName === prefix, one char string\n  // otherwise it should be passed into arguments\n\n  // FIXME if GET always return result of prefixed property, means there are\n  // no cases when we get a wrapped node to APPLY trap with prefixed name.\n  if (isValidPrefix(childName)) {\n    const handler = getPrefixHandler(childName);\n    return handler(\n      node,\n      adapter,\n      [childName.substr(1), ...argumentsList],\n      utils,\n    );\n  }\n\n  if (hasAugmentation(childName)) {\n    // INFO cannot use target because it contains method's childName, not Node childName\n    // call the function with saving context, so other augmentations are accessible via \"this\"\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\n  }\n\n  // in case of normal function being called out of the tree node\n  const targetNode = adapter.toNode(node);\n  if (typeof targetNode[childName] === 'function') {\n    return targetNode[childName](...argumentsList);\n  }\n\n  // FIXME might throw only in dev mode(needs implementation)\n  throw new Error(`\"${childName}\" is not a callable object.`);\n};\n\nhandlers = {\n  get,\n  has,\n  apply,\n};\n\nexport default wrap;\n","const toString = (node, adapter) =>\n  adapter.string ? adapter.string(node) : node.toString();\nconst valueOf = (node, adapter) => (adapter.value ? adapter.value(node) : node);\n\nexport default {\n  toString,\n  valueOf,\n};\n","/* eslint-disable prefer-spread */\nconst children = (node, adapter, [childName], utils) => {\n  let list;\n\n  if (childName) {\n    list = adapter.getChildrenByName(node, childName);\n  } else {\n    list = adapter.getChildren(node);\n  }\n\n  return utils.wrap(list, adapter);\n};\n\n/**\n * @internal\n */\nconst descendantsAll = (node, adapter, args, utils) => {\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = list[index];\n    children.push(child);\n    descendants.push.apply(\n      descendants,\n      descendantsAll(child, adapter, args, utils),\n    );\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\n/**\n * @internal\n */\nconst descendantsByName = (node, adapter, args, utils) => {\n  const [childName] = args;\n  const children = []; // eslint-disable-line no-shadow\n  const descendants = [];\n  const list = adapter.getChildren(node);\n  const length = adapter.getLength(list, adapter);\n\n  for (let index = 0; index < length; index += 1) {\n    const child = list[index];\n    if (adapter.getName(child) === childName) {\n      children.push(child);\n    }\n\n    descendants.push.apply(\n      descendants,\n      descendantsByName(child, adapter, args, utils),\n    );\n  }\n\n  /* children go first, then other descendants */\n  return [...children, ...descendants];\n};\n\nconst descendants = (node, adapter, args, utils) => {\n  const [childName] = args;\n\n  if (childName) {\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\n  }\n\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\n};\n\nconst childAt = (node, adapter, [index = 0], utils) =>\n  utils.wrap(adapter.getChildAt(node, index), adapter);\n\nconst root = (node, adapter, args, utils) =>\n  utils.wrap(adapter.getNodeRoot(node), adapter);\n\nconst parent = (node, adapter, args, utils) =>\n  utils.wrap(adapter.getNodeParent(node), adapter);\n\nexport default {\n  children,\n  descendants,\n  childAt,\n  root,\n  parent,\n};\n","const length = (node, adapter) => {\n  if (adapter.isList(node)) {\n    return adapter.getLength(node);\n  } else if (adapter.isNode(node)) {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst at = (node, adapter, args, utils) => {\n  const [index = 0] = args;\n  let result;\n\n  if (adapter.isList(node)) {\n    const child = adapter.getNodeAt(node, index);\n\n    if (child) {\n      result = child;\n    }\n  } else if (!index) {\n    result = node;\n  }\n\n  // if nothing found return empty array, which will create empty wrapper for\n  // chained calls, this will make next calls errorless.\n  return utils.wrap(result || [], adapter);\n};\n\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\n\nconst filter = (node, adapter, [callback], utils) => {\n  // apply filter on element collection\n  // always return wrapped list\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  const result = [];\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\n      result.push(child);\n    }\n  }\n\n  return utils.wrap(result, adapter);\n};\n\nconst map = (node, adapter, [callback], utils) => {\n  // apply map on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(list);\n  const result = [];\n\n  const wrappedList = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    const childResult = callback(\n      utils.wrap(child, adapter),\n      index,\n      wrappedList,\n    );\n    result.push(childResult);\n  }\n\n  // returns normal array because we don't know if all items in result are nodes\n  // and if they are, they will be likely already wrapped\n  return result;\n};\n\nconst reduce = (node, adapter, [callback, result], utils) => {\n  // apply reduce on element collection\n  const list = adapter.toList(node);\n  const listLength = adapter.getLength(node);\n  let lastResult = result;\n\n  const wrappedNode = utils.wrap(list, adapter);\n  for (let index = 0; index < listLength; index += 1) {\n    const child = adapter.getNodeAt(list, index);\n    lastResult = callback(\n      lastResult,\n      utils.wrap(child, adapter),\n      index,\n      wrappedNode,\n    );\n  }\n\n  return lastResult;\n};\n\nexport default {\n  length,\n  at,\n  first,\n  filter,\n  map,\n  reduce,\n};\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n\n  setNamePrefix,\n  isValidPrefix,\n\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","getDefaultAdapter","Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","namePrefixes","isValidPrefix","prefix","isPrefixedKey","key","length","charAt","getPrefixHandler","isIntKey","parseInt","String","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","toNode","getNodeList","toList","augmentations","addAugmentations","augs","hasAugmentation","handlers","utils","GET_RESTRICTED_NAMES","wrap","isNode","isList","Proxy","TreeWalker","Error","createWalkerNode","getNodeAt","handler","substr","result","hasChild","thisArg","argumentsList","args","applyAugmentation","targetNode","string","toString","descendantsAll","children","descendants","list","getChildren","getLength","index","child","push","apply","descendantsByName","getName","getChildAt","getNodeRoot","getNodeParent","at","callback","listLength","wrappedNode","wrappedList","childResult","lastResult","coreAugmentations","create","root","validateRoot"],"mappings":"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"}
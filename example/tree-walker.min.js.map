{"version":3,"file":"tree-walker.min.js","sources":["../source/default-adapter.js","../node_modules/@actualwave/has-own/has-own.js","../source/prefixes.js","../source/utils.js","../source/augmentations/index.js","../source/wrapper.js","../source/augmentations/core.js","../source/augmentations/node.js","../source/augmentations/list.js","../source/index.js"],"sourcesContent":["let defaultAdapter = null;\r\n\r\nexport const setDefaultAdapter = (adapter) => {\r\n  defaultAdapter = adapter;\r\n};\r\nexport const getDefaultAdapter = () => defaultAdapter;\r\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\r\n\r\nconst namePrefixes = {};\r\n\r\nexport const isValidPrefix = (prefix) =>\r\n  typeof prefix === 'string' &&\r\n  prefix.length === 1 &&\r\n  hasOwn(namePrefixes, prefix);\r\n\r\nexport const isPrefixedKey = (key) =>\r\n  key &&\r\n  typeof key === 'string' &&\r\n  key.length > 1 &&\r\n  hasOwn(namePrefixes, key.charAt());\r\n\r\nexport const getPrefixHandler = (key) => namePrefixes[key.charAt()];\r\n\r\nexport const setNamePrefix = (prefix, handler) => {\r\n  if (typeof prefix !== 'string' || prefix.length !== 1) {\r\n    throw new Error('Name Prefix must be one character string.');\r\n  }\r\n\r\n  namePrefixes[prefix] = handler;\r\n};\r\n","export const isIntKey = (key) => (`${parseInt(key, 10)}` === key);\r\n\r\nexport const getValue = (node, adapter, childName = undefined) => {\r\n  if (childName !== undefined) {\r\n    return adapter.getChildrenByName(node, childName);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nexport const getSingleNode = (node, adapter, childName = undefined) => {\r\n  const value = getValue(node, adapter, childName);\r\n\r\n  if (adapter.isList(value)) {\r\n    return adapter.getNodeAt(node);\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nexport const getNodeList = (node, adapter, childName = undefined) => {\r\n  return adapter.toList(getValue(node, adapter, childName));\r\n};\r\n","let augmentations = {};\r\n\r\nexport const resetAugmentations = (augs = {}) => {\r\n  augmentations = augs;\r\n};\r\n\r\nexport const addAugmentations = (augs = {}) => {\r\n  augmentations = {\r\n    ...augmentations,\r\n    ...augs,\r\n  };\r\n};\r\n\r\nexport const hasAugmentation = (key) => (\r\n  key\r\n  && typeof key === 'string'\r\n  && augmentations.hasOwnProperty(key)\r\n);\r\n\r\nexport const getAugmentation = (key) => augmentations[key];\r\n\r\nexport const applyAugmentation = (key, ...args) => augmentations[key](...args);\r\n","import {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n} from './utils';\r\n\r\nimport {\r\n  isPrefixedKey,\r\n  isValidPrefix,\r\n  getPrefixHandler,\r\n} from './prefixes';\r\n\r\nimport {\r\n  hasAugmentation,\r\n  applyAugmentation,\r\n} from './augmentations';\r\n\r\nlet handlers;\r\nlet utils;\r\n\r\nconst createWalkerNode = (node, adapter, childName = undefined) => {\r\n  function TreeWalker() {\r\n    throw new Error('Should have been never called');\r\n  }\r\n\r\n  // can be single Node and NodeList with length >= 0\r\n  // should it be always NodeList?\r\n  TreeWalker.node = node;\r\n  // childName always String/Symbol, Number's are being handled in proxy get wrapper\r\n  // INFO \"name\" is RO property of Function object\r\n  TreeWalker.childName = childName;\r\n  TreeWalker.adapter = adapter;\r\n  return TreeWalker;\r\n};\r\n\r\nconst wrap = (node, adapter, childName = undefined) => {\r\n  if (!adapter.isNode(node) && !adapter.isList(node)) {\r\n    return node;\r\n  }\r\n\r\n  return new Proxy(createWalkerNode(node, adapter, childName), handlers);\r\n};\r\n\r\n// eslint-disable-next-line\r\nutils = {\r\n  isIntKey,\r\n  getValue,\r\n  getSingleNode,\r\n  getNodeList,\r\n  wrap,\r\n};\r\n\r\nconst get = ({ node, adapter, childName }, key) => {\r\n  /*\r\n   if string childName used\r\n   if starts with $, return attribute value\r\n   else return wrapper with current single node and property childName\r\n   if numeric index used, use node as parent and childName is undefined\r\n   */\r\n  if (isIntKey(key)) {\r\n    return wrap(adapter.getNodeAt(getNodeList(node, adapter, childName), key), adapter);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    const handler = getPrefixHandler(key);\r\n    return handler(getValue(node, adapter, childName), adapter, [key.substr(1)], utils);\r\n  }\r\n\r\n  // return wrap with node and childName\r\n  return wrap(getValue(node, adapter, childName), adapter, key);\r\n};\r\n\r\nconst has = ({ node, adapter, childName }, key) => {\r\n  if (isIntKey(key)) {\r\n    return !!adapter.getNodeAt(getNodeList(node, adapter, childName), key);\r\n  }\r\n\r\n  if (isPrefixedKey(key)) {\r\n    // return adapter.hasAttribute(getSingleNode(node, adapter, childName), key.substr(1));\r\n    // don't know how to implement this, calling same handler as in GET seems overkill\r\n    return true;\r\n  }\r\n\r\n  return adapter.hasChild(getSingleNode(), key);\r\n};\r\n\r\nconst apply = ({ node, adapter, childName }, thisArg, argumentsList) => {\r\n  if (childName === undefined) {\r\n    throw new Error('Cannot call on TreeWalker Node');\r\n  }\r\n\r\n  // this works only of childName === prefix, one char string\r\n  // otherwise it should be passed into arguments\r\n  if (isValidPrefix(childName)) {\r\n    const handler = getPrefixHandler(childName);\r\n    return handler(node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  if (hasAugmentation(childName)) {\r\n    // INFO cannot use target because it contains method's childName, not Node childName\r\n    // call the function with saving context, so other augmentations are accessible via \"this\"\r\n    return applyAugmentation(childName, node, adapter, argumentsList, utils);\r\n  }\r\n\r\n  // FIXME might throw only in dev mode(needs implementation)\r\n  throw new Error(`\"${childName}\" is not a callable object.`);\r\n};\r\n\r\nhandlers = {\r\n  get,\r\n  has,\r\n  apply,\r\n};\r\n\r\nexport default wrap;\r\n\r\n","const toString = (node) => node.toString();\r\nconst valueOf = (node) => node;\r\n\r\nexport default {\r\n  toString,\r\n  valueOf,\r\n  [Symbol.toPrimitive]: (node) => node,\r\n};\r\n","/* eslint-disable prefer-spread */\r\nconst children = (node, adapter, [childName], utils) => {\r\n  let list;\r\n\r\n  if (childName) {\r\n    list = adapter.getChildrenByName(node, childName);\r\n  } else {\r\n    list = adapter.getChildren(node);\r\n  }\r\n\r\n  return utils.wrap(list, adapter);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsAll = (node, adapter, args, utils) => {\r\n  const result = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    result.push(child);\r\n    result.push.apply(result, descendantsAll(child, adapter, args, utils));\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst descendantsByName = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n  const result = [];\r\n  const list = adapter.getChildren(node);\r\n  const length = adapter.getLength(list, adapter);\r\n\r\n  for (let index = 0; index < length; index += 1) {\r\n    const child = list[index];\r\n    if (adapter.getName(child) === childName) {\r\n      result.push(child);\r\n    }\r\n    result.push.apply(result, descendantsByName(child, adapter, args, utils));\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nconst descendants = (node, adapter, args, utils) => {\r\n  const [childName] = args;\r\n\r\n  if (childName) {\r\n    return utils.wrap(descendantsByName(node, adapter, args, utils), adapter);\r\n  }\r\n\r\n  return utils.wrap(descendantsAll(node, adapter, args, utils), adapter);\r\n};\r\n\r\nconst childAt = (node, adapter, [index = 0], utils) =>\r\n  utils.wrap(adapter.getChildAt(node, index), adapter);\r\n\r\nconst root = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeRoot(node), adapter);\r\n\r\nconst parent = (node, adapter, args, utils) =>\r\n  utils.wrap(adapter.getNodeParent(node), adapter);\r\n\r\nexport default {\r\n  children,\r\n  descendants,\r\n  childAt,\r\n  root,\r\n  parent\r\n};\r\n","const length = (node, adapter) => {\r\n  if (adapter.isList(node)) {\r\n    return adapter.getLength(node);\r\n  } else if (adapter.isNode(node)) {\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nconst at = (node, adapter, args, utils) => {\r\n  const [index] = args;\r\n  // return empty array, which will create empty wrapper for chained calls,\r\n  // this will make next calls errorless.\r\n  let result = [];\r\n\r\n  if (adapter.isList(node)) {\r\n    const child = adapter.getNodeAt(node, index);\r\n\r\n    if (child) {\r\n      result = child;\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst first = (node, adapter, args, utils) => at(node, adapter, [0], utils);\r\n\r\nconst filter = (node, adapter, [callback], utils) => {\r\n  // apply filter on element collection\r\n  // always return wrapped list\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  const result = [];\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    if (callback(utils.wrap(child, adapter), index, wrappedNode)) {\r\n      result.push(child);\r\n    }\r\n  }\r\n\r\n  return utils.wrap(result, adapter);\r\n};\r\n\r\nconst map = (node, adapter, [callback, wrapNodes = true], utils) => {\r\n  // apply map on element collection\r\n  // if wrapNodes in FALSE, will generate normal Array with RAW results in it\r\n  // if wrapNodes in TRUE and all elements of resulting list are nodes, will\r\n  //   generate wrapped list and put all result into it\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(list);\r\n  const result = [];\r\n\r\n  let areNodes = true;\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    const childResult = callback(\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedNode\r\n    );\r\n    areNodes = areNodes && adapter.isNode(childResult);\r\n    result.push(childResult);\r\n  }\r\n\r\n  return wrapNodes && areNodes ? utils.wrap(result, adapter) : result;\r\n};\r\n\r\nconst reduce = (node, adapter, [callback, result], utils) => {\r\n  // apply reduce on element collection\r\n  const list = adapter.toList(node);\r\n  const listLength = adapter.getLength(node);\r\n  let lastResult = result;\r\n\r\n  const wrappedNode = utils.wrap(list, adapter);\r\n  for (let index = 0; index < listLength; index += 1) {\r\n    const child = adapter.getNodeAt(list, index);\r\n    lastResult = callback(\r\n      result,\r\n      utils.wrap(child, adapter),\r\n      index,\r\n      wrappedNode\r\n    );\r\n  }\r\n\r\n  return lastResult;\r\n};\r\n\r\nexport default {\r\n  length,\r\n  at,\r\n  first,\r\n  filter,\r\n  map,\r\n  reduce\r\n};\r\n","import { setDefaultAdapter, getDefaultAdapter } from './default-adapter';\nimport { setNamePrefix, isValidPrefix } from './prefixes';\nimport wrap from './wrapper';\nimport { addAugmentations, resetAugmentations, hasAugmentation } from './augmentations';\nimport coreAugmentations from './augmentations/core';\nimport nodeAugmentations from './augmentations/node';\nimport listAugmentations from './augmentations/list';\n\naddAugmentations(coreAugmentations);\n\nconst create = (root, adapter = getDefaultAdapter()) =>\n  wrap(adapter.validateRoot(root), adapter);\n\nexport {\n  setDefaultAdapter,\n  getDefaultAdapter,\n\n  addAugmentations,\n  hasAugmentation,\n  resetAugmentations,\n  coreAugmentations,\n  nodeAugmentations,\n  listAugmentations,\n\n  setNamePrefix,\n  isValidPrefix,\n\n  create,\n};\n\nexport default create;\n"],"names":["defaultAdapter","getDefaultAdapter","Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","namePrefixes","isValidPrefix","prefix","length","isPrefixedKey","key","charAt","getPrefixHandler","isIntKey","parseInt","getValue","node","adapter","childName","undefined","getChildrenByName","getSingleNode","isList","getNodeAt","getNodeList","toList","augmentations","addAugmentations","augs","hasAugmentation","handlers","utils","wrap","isNode","Proxy","TreeWalker","Error","createWalkerNode","handler","substr","hasChild","thisArg","argumentsList","args","applyAugmentation","toString","Symbol","toPrimitive","descendantsAll","result","list","getChildren","getLength","index","child","push","apply","descendantsByName","getName","getChildAt","getNodeRoot","getNodeParent","at","callback","listLength","wrappedNode","wrapNodes","areNodes","childResult","lastResult","coreAugmentations","create","root","validateRoot"],"mappings":"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"}